/* Juan's Grammar for CS152 */
/* mini_l.y */

%{
#define YY_NO_UNPUT

#include "headers.h"

extern int currLine;	
extern int currPos;
extern char *yytext;

void yyerror(char const*);
int yylex(void);

/*
struct symbolDetails{
   symbolDetails():value(0){}
   string type;
   int value;
};
*/

struct Symbol{
   Symbol():value(777){}
   Symbol(string n):name(n) {}
   Symbol(string n, string t): name(n), type(t){}
   Symbol(string n, int v):name(n), value(v), type("INTEGER") {}
   string name;
   string type;
   int limit;  // for arrays
   int value;
   bool operator==(const string &rhs) { return !(this->name.compare(rhs));}
};

typedef vector<string> vecStr;
//typedef map<string, symbolDetails> Table;
typedef vector<Symbol> Table;
typedef stack<string> stackStr;


bool inTable(string);
bool inArrayList(string);
string genQuad(string op, string src1, string src2, string dest);
string newLabel();
string newTemp();
string newPred();
Table symTable;
int currentTemp = 1; 	// the current number of temporary variables
int currentLabel = 1; 	// the current number of labels
int currentPred = 1;    // the current predicate

vecStr milCode;		// holds the code generated
stackStr identStack;   	// holds list of identifiers seen
vecStr labels;		// holds the labels
bool isReading = false;

%}
%union{
   int		iVal;
   string* 	strVal;
typedef struct Attributes{
   string* name;
   string* code;
   string* type;
   int limit; // for arrays
   int value;
}Attributes;
   Attributes attribute;
};


%error-verbose
%token		FUNCTION INTEGER OF ARRAY READ IF THEN ENDIF ELSE WHILE DO 
%token		BEGIN_PARAMS BEGIN_LOCALS BEGIN_BODY IN BEGINLOOP ENDLOOP RETURN
%token		END_PARAMS END_LOCALS END_BODY CONTINUE WRITE TRUE FALSE FOREACH 
%token 		SEMICOLON COLON COMMA L_PAREN R_PAREN L_SQUARE_BRACKET R_SQUARE_BRACKET 
%token <iVal> 	NUMBER
%token <strVal>	IDENT

%right		UMINUS
%left		MULT DIV MOD
%left   	ADD SUB 
%left		LT LTE GT GTE EQ NEQ
%right		NOT 
%left		AND
%left		OR
%right  	ASSIGN

%type<iVal> number
%type<strVal> ident identifiers
%type<attribute> comp var vars term expression multiplicative_expression expressions statement statements
%type<attribute> bool_exp relation_exp relation_and_exp 


%%
prog_start:	functions {
//		for (auto symbol : symTable) cout << symbol.name << endl;
		}
                ;
functions:	function functions
                | /*empty*/
                ;
function: 	FUNCTION IDENT SEMICOLON BEGIN_PARAMS declarations END_PARAMS BEGIN_LOCALS declarations END_LOCALS BEGIN_BODY statements END_BODY {

                }
                ;
declarations:	declaration SEMICOLON declarations
                | /*empty*/
                ;

declaration:    identifiers COLON INTEGER {
			while (!identStack.empty()) {
			symTable.push_back(Symbol(identStack.top(), "INTEGER"));
			cout << "declaration -> identifiers: " << symTable.back().name << endl;
			identStack.pop();
			}
                }
		| identifiers COLON ARRAY L_SQUARE_BRACKET number R_SQUARE_BRACKET OF INTEGER {
			while (!identStack.empty()) {
			Symbol sym(identStack.top(), "ARRAY");
			sym.limit = $5;
			symTable.push_back(sym);
			cout << "declaration -> identifiers array: " << symTable.back().name << endl;
			identStack.pop();
			}
		}
                ;

statements:       statement SEMICOLON statements
                | /*empty*/
                ;

statement:        var ASSIGN expression {
			string ident = *($1.name);
			Table::iterator iter = find(symTable.begin(), symTable.end(), ident);
			cout << "SEARCHING for: " << ident << endl;
			if (iter == symTable.end()) cout << "ERRRRRORRRR\n";
			else iter->value = $3.value;
			
//			cout << "PUSHED back: " << symTable.back().name << endl;
			milCode.push_back("= " + ident + ", " + *($3.name));
			cout << milCode.back() << endl;
		}
                | IF ifCond ENDIF
                | IF ifCond ELSE statements ENDIF
       		| WHILE bool_exp loop
		| DO loop WHILE bool_exp
  		| FOREACH IDENT IN IDENT loop
		| READ M1 vars
                | WRITE M2 vars
                | CONTINUE
                | RETURN expression
                ;

M1:		/*empty*/ {isReading = true;}
M2:		/*empty*/ {isReading = false;}

ifCond:		bool_exp THEN statements
                ;

loop:		BEGINLOOP statements ENDLOOP
                ;

bool_exp:	  relation_and_exp {
			*($$.name) = *($1.name);
		}
                | relation_and_exp OR relation_and_exp {
			string temp = newPred();
			*($$.name) = temp;
			milCode.push_back(genQuad("||", *($1.name), *($3.name), temp));
			cout << milCode.back() << endl;
		}
		
		; 

relation_and_exp: relation_exp {
			$$.name = $1.name;
		}
                | relation_exp AND relation_and_exp {
			string temp = newPred();
			*($$.name) = temp;
			milCode.push_back(genQuad("&&", *($1.name), *($3.name), temp));
			cout << milCode.back() << endl;
		}
                ;

relation_exp:	  NOT relation_exp {
			*($$.name) = "TESTING2\n";	

		}
		| expression comp expression
                | TRUE { *($$.name) = "true";}
                | FALSE { *($$.name) = "false";}
                | L_PAREN bool_exp R_PAREN { *($$.name) = *($2.name);}
                ;

comp:	   	  EQ  { $$.name = new string("==");}
		| NEQ { $$.name = new string("<>");}
		| LT  { $$.name = new string("<");}
		| GT  { $$.name = new string(">");}
		| LTE { $$.name = new string("<=");}
		| GTE { $$.name = new string(">=");}
                ;

expression:	  multiplicative_expression {
			*($$.name) = *($1.name);
			$$.value = $1.value;
		}
                | expression ADD multiplicative_expression {
			string temp = newTemp();
			*($$.name) = temp;
			$$.value = $1.value + $3.value;
//			cout << "TESTING add " << $$.value << " =  " << $1.value << " + " << $3.value << endl;
//			cout << "ADD: " << temp << "= " <<*($1.name) <<" + " <<*($3.name) << endl;
			symTable.push_back(Symbol(temp, $$.value)); // CORRECT?
			milCode.push_back(genQuad("+", *($1.name), *($3.name), temp));
			cout << milCode.back() << endl;
		}
                | expression SUB multiplicative_expression {
			string temp = newTemp();
			*($$.name) = temp;
			$$.value = $1.value - $3.value;
			symTable.push_back(Symbol(temp, $$.value)); // CORRECT?
			
//			cout << "TESTING add " << $$.value << " =  " << $1.value << " - " << $3.value << endl;
			symTable.push_back(Symbol(temp, $$.value)); // CORRECT?
			milCode.push_back(genQuad("-", *($1.name), *($3.name), temp));
			cout << milCode.back() << endl;
		}
		;

multiplicative_expression:	  term {
					*($$.name) = *($1.name);
					$$.value = $1.value;
				}
				| term MULT term {
					string temp = newTemp();
					*($$.name) = temp;
					$$.value = $1.value * $3.value;
//					cout << "TESTING mult " << $$.value << " =  " << $1.value << " * " << $3.value << endl;
			symTable.push_back(Symbol(temp, $$.value)); // CORRECT?
					milCode.push_back(genQuad("*", *($1.name), *($3.name), temp));
					cout << milCode.back() << endl;
				}
				| term DIV term {
					string temp = newTemp();
					*($$.name) = temp;
					$$.value = $1.value / $3.value;
			symTable.push_back(Symbol(temp, $$.value)); // CORRECT?
					milCode.push_back(genQuad("/", *($1.name), *($3.name), temp));
					cout << milCode.back() << endl;
				}
				| term MOD term {
					string temp = newTemp();
					*($$.name) = temp;
					$$.value = $1.value % $3.value;
					milCode.push_back(genQuad("%", *($1.name), *($3.name), temp));
			symTable.push_back(Symbol(temp, $$.value)); // CORRECT?
					cout << milCode.back() << endl;
				}
                		;

term:		  SUB number %prec UMINUS {
//			cout << "XZzzXX\n";
			string temp = newTemp();
			*($$.name) = temp;
			$$.value = -($2);
			symTable.push_back(Symbol(temp, $$.value)); // CORRECT?
			milCode.push_back(genQuad("-", "0",to_string($2),temp)); /// CHANGE THIS
			cout << milCode.back() << endl;
                  }
                | number {
//			cout << "YYYYYY\n";
			$$.name = new string(to_string($1));
			$$.value = $1;
//			cout << "term -> " << *($$.name) << endl;
                 }
		| var { 
//			cout << "ZZZZ\n";
//			cout << "222222222\n";
			*($$.name) = *($1.name);
			$$.value = $1.value;
			cout << "VALUE: " << $$.value << endl;
//			cout << "term -> " << *($$.name) << endl;
		}
		| SUB var %prec UMINUS {
//			cout << "AAAAA\n";
		        string temp = newTemp();
		        *($$.name) = *($2.name);
			symTable.push_back(Symbol(temp, $2.value)); // CORRECT?
			milCode.push_back(genQuad("-", "0", *($2.name), temp));
			cout << milCode.back() << endl;
                  }
                | L_PAREN expression R_PAREN {
//			cout << "BBBBBB\n";
			*($$.name) = *($2.name);
			$$.value = $2.value;
//			cout << "term -> (" << *($$.name) << " " <<  $$.value << " )\n";
		  }
                | SUB L_PAREN expression R_PAREN  %prec UMINUS {
//			cout << "CCCCCC\n";
			string temp = newTemp();
			*($$.name) = temp;
			symTable.push_back(Symbol(temp, $3.value)); // CORRECT?
			milCode.push_back(genQuad("-", "0",*($3.name),temp));
			cout << milCode.back() << endl;
}
		| ident L_PAREN expressions R_PAREN {
//			cout << "DDDDDDD\n";
		 	*($$.name) = *($1);
			$$.value = $3.value;
//			cout << "term -> " + *($$.name) + " ( " + *($3.name) + " " << $3.value << " )\n";
		}
		;

expressions:	  expression {
			*($$.name) = *($1.name);	
//			cout << "expressions -> " + *($$.name);
		 }
		| expression COMMA expressions {
//			cout << "expressions:  ->" + *($1.name) + *($3.name)  << endl;
		}
			
		;

vars:		  var {
		        string temp= *($1.name);
		        if (isReading) milCode.push_back(".< " + temp);
		        else milCode.push_back(".> " + temp);
			cout << milCode.back() << endl;
		}
                | var COMMA vars {
//			cout << "vars -> " << *($1.name) << " COMMA " << *($3.name) << endl;
		}
                ;

var:		ident{
			cout << "var sees: " << *($1) << endl;
			string ident = *($1);
			Table::iterator iter = find(symTable.begin(), symTable.end(), ident);
		        // ident not in symbol table
		    	if (iter == symTable.end()) {
				cout << "Error: " << ident << " was not declared. "
				<< "Line " << currLine << ", position " << currPos << endl;
			}
			else {
				cout << "var VALUE is: " << iter->value << endl;
				$$.value = iter->value;
		}
//		    }
/*
                    else {
			if (iter->second.type != "INTEGER") cout << "ERROR, invalid type (var)\n";
		        else {
				$$.value = iter->second.value;
			}
		   } 
*/
                    *($$.name) = *($1);
                  }
                | ident L_SQUARE_BRACKET expression R_SQUARE_BRACKET {
/*
		    string ident = *($1);
		    Table::iterator iter = symTable.find(ident);
		    // ident not in symbol table
		    if (iter == symTable.end()) {
			cout << "Error: " << ident << " was not declared. "
			     << "Line " << currLine << ", position " << currPos << endl;
		    }
                    else {
			if (iter->second.type == "INTEGER") cout << "ERROR, invalid type (var)\n";
		        else $$.value = iter->second.value;
		   } 
*/
                    *($$.name) = *($1);
//			cout << "var -> " << *($1) << "[ " + *($3.name) << " " << $3.value <<" ]\n";
                }
		;

identifiers:      ident {
			*($$) = *($1);
		}
                   
		| ident COMMA identifiers{ 
                }
		;

ident:		IDENT {
			*($$) = "_" + *($1);
                    Table::iterator ident = find(symTable.begin(), symTable.end(), *($$));
		    // new symbol
		    if (ident == symTable.end()) identStack.push(*($$));
                }
		
number:		NUMBER {
		    $$ = $1;
		}
                ;
%%

int main() {
   yyparse();

   return 0;
}

void yyerror (char const *s)
{
  fprintf (stderr, "error at line %d:  \"%s\"\n", currLine, s);
}

string newTemp() {
    return "t" + to_string(currentTemp++);
}

string newLabel() {
    return "L" + to_string(currentLabel++);
}

string newPred() {
    return "p" + to_string(currentPred++);
}

string genQuad(string op, string src1, string src2, string dest) {
    return op + " " + dest + ", " + src1 + ", " + src2; 
}
